#pragma comment (lib, "Opengl32.lib") // needed for render context (openGL)

#include <Windows.h> // allow to create window
#include <gl/GL.h> // core openGL functions 

#include <stdint.h> // for class Pixel suports uint32_t
#include <thread> // allow for messageloop and engineloop to work at the same time (NEEDED!)
#include <chrono> // you know speed of engineloop
#include <string> // using it for convertion
#include <map> // used in keys(buttons)
#include <math.h> // used for rotation in shapes
#include <stack>
#include <vector>
#include <time.h>

class Pixel
{
public:
	union
	{
		uint32_t n = 0xFF000000;
		class
		{
		public:
			uint8_t r, g, b, a;
		};
	};
	Pixel()
	{
		r = 0;
		g = 0;
		b = 0;
		a = 255;
	}
	Pixel(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha = 255)
	{
		r = red;
		g = green;
		b = blue;
		a = alpha;
	}
	Pixel(uint32_t pixel)
	{
		n = pixel;
	}

	bool operator==(const Pixel& p) const
	{
		return n == p.n;
	}

	bool operator!=(const Pixel& p) const
	{
		return n != p.n;
	}
};

class Button
{
public:
	bool press = 0;
	bool release = 0;
	bool hold = 0;
};

enum Key
{
	A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
	K0, K1, K2, K3, K4, K5, K6, K7, K8, K9,
	F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
	UP, DOWN, LEFT, RIGHT,
	ESC, TAB, CAPSLOCK, SHIFT, CTRL, ALT, SPACE, ENTER, BACKSPACE, INS,
	DEL, PGUP, PGDN, HOME, END,
	NK0, NK1, NK2, NK3, NK4, NK5, NK6, NK7, NK8, NK9,
	NK_ADD, NK_SUBTRACT, NK_MULTIPLY, NK_DIVIDE, NK_DECIMAL,
};

enum MouseKey
{
	MOUSE_LEFT, MOUSE_RIGHT, MOUSE_MIDDLE
};

// Usable
std::string ApplicationName = "GRAPHICS ENGINE";

int ScreenWidth;
int ScreenHeight;

int MousePositionX;
int MousePositionY;

float ElapsedTime = 0.0f;
bool EngineStatus = 0;

// Not Usable
int PixelWidth;
int PixelHeight;

int WindowWidth;
int WindowHeight;

int ViewportWidth;
int ViewportHeight;
int ViewportX;
int ViewportY;

int MPX;
int MPY;

std::map<size_t, uint8_t> MapKey;
Button KeyState[256];
bool KeyNewState[256]{ 0 };
bool KeyOldState[256]{ 0 };

Button MouseState[3];
bool MouseNewState[3]{ 0 };
bool MouseOldState[3]{ 0 };

float FrameTime = 1.0f;
int FrameCount = 0;

Pixel* pixel = nullptr;
HWND hWnd = nullptr;
HDC DeviceContext = nullptr;
HGLRC RenderContext = nullptr;
GLuint Texture;

void SetWindowSize(int screen_width, int screen_height, int pixel_width = 1, int pixel_height = 1)
{
	ScreenWidth = screen_width;
	ScreenHeight = screen_height;
	PixelWidth = pixel_width;
	PixelHeight = pixel_height;

	pixel = new Pixel[ScreenWidth * ScreenHeight];
}

void UpdateWindow(int width, int height)
{
	WindowWidth = width;
	WindowHeight = height;

	float slope = (float)(ScreenHeight * PixelHeight) / (float)(ScreenWidth * PixelWidth);

	ViewportWidth = WindowWidth;
	ViewportHeight = (int)((float)ViewportWidth * slope);

	if (ViewportHeight > WindowHeight)
	{
		ViewportHeight = WindowHeight;
		ViewportWidth = (int)((float)ViewportHeight / slope);
	}

	ViewportX = (WindowWidth - ViewportWidth) / 2;
	ViewportY = (WindowHeight - ViewportHeight) / 2;
}

void UpdateMouse(int x, int y)
{
	MPX = (int)((float)(x - ViewportX) / (float)ViewportWidth * (float)ScreenWidth);
	MPY = (int)((float)(y - ViewportY) / (float)ViewportHeight * (float)ScreenHeight);

	if (MPX < 0) MPX = 0;
	if (MPY < 0) MPY = 0;
	if (MPX >= ScreenWidth) MPX = ScreenWidth - 1;
	if (MPY >= ScreenHeight) MPY = ScreenHeight - 1;
}

LRESULT CALLBACK WindowEvents(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_KEYDOWN:
		KeyNewState[MapKey[wParam]] = 1;
		return 0;
	case WM_KEYUP:
		KeyNewState[MapKey[wParam]] = 0;
		return 0;
	case WM_LBUTTONDOWN:
		MouseNewState[0] = 1;
		return 0;
	case WM_LBUTTONUP:
		MouseNewState[0] = 0;
		return 0;
	case WM_RBUTTONDOWN:
		MouseNewState[1] = 1;
		return 0;
	case WM_RBUTTONUP:
		MouseNewState[1] = 0;
		return 0;
	case WM_MBUTTONDOWN:
		MouseNewState[2] = 1;
		return 0;
	case WM_MBUTTONUP:
		MouseNewState[2] = 0;
		return 0;
	case WM_MOUSEMOVE:
		UpdateMouse(LOWORD(lParam), HIWORD(lParam));
		return 0;
	case WM_SIZE:
		UpdateWindow(LOWORD(lParam), HIWORD(lParam));
		return 0;
	case WM_CLOSE:
		EngineStatus = 0;
		return 0;
	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}
}

void CreateMainWindow()
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wcex.lpfnWndProc = WindowEvents;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = GetModuleHandle(nullptr);
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = nullptr;
	wcex.lpszMenuName = nullptr;
	wcex.lpszClassName = L"GRAPHICS_ENGINE";
	wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	RegisterClassEx(&wcex);

	DWORD dwExStyle = NULL;
	DWORD dwStyle = WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_THICKFRAME | WS_MINIMIZEBOX;

	// Client Area
	RECT WindowRect = { 0, 0, ScreenWidth * PixelWidth, ScreenHeight * PixelHeight };
	AdjustWindowRectEx(&WindowRect, dwStyle, 0, dwExStyle);
	int width = WindowRect.right - WindowRect.left;
	int height = WindowRect.bottom - WindowRect.top;

	// Application Name Conversion
	std::wstring title = std::wstring(ApplicationName.begin(), ApplicationName.end());

	hWnd = CreateWindowEx(dwExStyle, L"GRAPHICS_ENGINE", title.c_str(), dwStyle, 0, 0,
		width, height, NULL, NULL, GetModuleHandle(nullptr), NULL);

	//// Keyboard Mapping
	// Alphabet
	MapKey[0x41] = Key::A; MapKey[0x42] = Key::B; MapKey[0x43] = Key::C; MapKey[0x44] = Key::D; MapKey[0x45] = Key::E;
	MapKey[0x46] = Key::F; MapKey[0x47] = Key::G; MapKey[0x48] = Key::H; MapKey[0x49] = Key::I; MapKey[0x4A] = Key::J;
	MapKey[0x4B] = Key::K; MapKey[0x4C] = Key::L; MapKey[0x4D] = Key::M; MapKey[0x4E] = Key::N; MapKey[0x4F] = Key::O;
	MapKey[0x50] = Key::P; MapKey[0x51] = Key::Q; MapKey[0x52] = Key::R; MapKey[0x53] = Key::S; MapKey[0x54] = Key::T;
	MapKey[0x55] = Key::U; MapKey[0x56] = Key::V; MapKey[0x57] = Key::W; MapKey[0x58] = Key::X; MapKey[0x59] = Key::Y;
	MapKey[0x5A] = Key::Z;

	// Keys 0-9
	MapKey[0x30] = Key::K0; MapKey[0x31] = Key::K1; MapKey[0x32] = Key::K2; MapKey[0x33] = Key::K3; MapKey[0x34] = Key::K4;
	MapKey[0x35] = Key::K5; MapKey[0x36] = Key::K6; MapKey[0x37] = Key::K7; MapKey[0x38] = Key::K8; MapKey[0x39] = Key::K9;

	// Function Keys
	MapKey[VK_F1] = Key::F1; MapKey[VK_F2] = Key::F2; MapKey[VK_F3] = Key::F3; MapKey[VK_F4] = Key::F4; MapKey[VK_F5] = Key::F5;
	MapKey[VK_F6] = Key::F6; MapKey[VK_F7] = Key::F7; MapKey[VK_F8] = Key::F8; MapKey[VK_F9] = Key::F9; MapKey[VK_F10] = Key::F10;
	MapKey[VK_F11] = Key::F11; MapKey[VK_F12] = Key::F12;

	// Arrow Keys
	MapKey[VK_LEFT] = Key::LEFT; MapKey[VK_RIGHT] = Key::RIGHT; MapKey[VK_UP] = Key::UP; MapKey[VK_DOWN] = Key::DOWN;

	// Miscellaneous Keys
	MapKey[VK_ESCAPE] = Key::ESC; MapKey[VK_TAB] = Key::TAB; MapKey[VK_CAPITAL] = Key::CAPSLOCK; MapKey[VK_SHIFT] = Key::SHIFT;
	MapKey[VK_CONTROL] = Key::CTRL; MapKey[VK_MENU] = Key::ALT; MapKey[VK_SPACE] = Key::SPACE; MapKey[VK_RETURN] = Key::ENTER;
	MapKey[VK_BACK] = Key::BACKSPACE; MapKey[VK_INSERT] = Key::INS; MapKey[VK_DELETE] = Key::DEL; MapKey[VK_PRIOR] = Key::PGUP;
	MapKey[VK_NEXT] = Key::PGDN; MapKey[VK_HOME] = Key::HOME; MapKey[VK_END] = Key::END;

	// Numeric Keypad
	MapKey[VK_NUMPAD0] = Key::NK0; MapKey[VK_NUMPAD1] = Key::NK1; MapKey[VK_NUMPAD2] = Key::NK2; MapKey[VK_NUMPAD3] = Key::NK3;
	MapKey[VK_NUMPAD4] = Key::NK4; MapKey[VK_NUMPAD5] = Key::NK5; MapKey[VK_NUMPAD6] = Key::NK6; MapKey[VK_NUMPAD7] = Key::NK7;
	MapKey[VK_NUMPAD8] = Key::NK8; MapKey[VK_NUMPAD9] = Key::NK9;

	MapKey[VK_ADD] = Key::NK_ADD; MapKey[VK_SUBTRACT] = Key::NK_SUBTRACT; MapKey[VK_MULTIPLY] = Key::NK_MULTIPLY;
	MapKey[VK_DIVIDE] = Key::NK_DIVIDE; MapKey[VK_DECIMAL] = Key::NK_DECIMAL;
}

Button GetKey(Key key)
{
	return KeyState[key];
}

Button GetMouseKey(MouseKey mouse_key)
{
	if (mouse_key == MOUSE_LEFT) return MouseState[0];
	if (mouse_key == MOUSE_RIGHT) return MouseState[1];
	if (mouse_key == MOUSE_MIDDLE) return MouseState[2];
}

void ClearScreen(Pixel p = Pixel(0, 0, 0))
{
	for (int i = 0; i < ScreenWidth * ScreenHeight; i++)
	{
		pixel[i] = p;
	}
}

void DrawPixel(int x, int y, Pixel p)
{
	if (x >= 0 && y >= 0 && x < ScreenWidth && y < ScreenHeight)
	{
		pixel[ScreenWidth * y + x] = p;
	}
}

Pixel GetPixel(int x, int y)
{
	if (x >= 0 && y >= 0 && x < ScreenWidth && y < ScreenHeight)
	{
		return pixel[ScreenWidth * y + x];
	}

	return Pixel(0, 0, 0);
}

void DrawLine(int x1, int y1, int x2, int y2, Pixel color)
{
	if (x1 == x2)
	{
		if (y1 > y2)
		{
			std::swap(y1, y2);
		}

		for (int y = y1; y <= y2; y++)
		{
			DrawPixel(x1, y, color);
		}
	}
	else if (y1 == y2)
	{
		if (x1 > x2)
		{
			std::swap(x1, x2);
		}

		for (int x = x1; x <= x2; x++)
		{
			DrawPixel(x, y1, color);
		}
	}
	else
	{
		int dx = std::abs(x2 - x1);
		int dy = std::abs(y2 - y1);

		if (dx > dy)
		{
			if (x1 > x2)
			{
				std::swap(x1, x2);
				std::swap(y1, y2);
			}

			int y = y1;
			int yi = y1 > y2 ? -1 : 1;
			int D = 2 * dy - dx;

			for (int x = x1; x <= x2; x++)
			{
				DrawPixel(x, y, color);
				if (D > 0)
				{
					y += yi;
					D -= 2 * dx;
				}

				D += 2 * dy;
			}
		}
		else
		{
			if (y1 > y2)
			{
				std::swap(x1, x2);
				std::swap(y1, y2);
			}

			int x = x1;
			int xi = x1 > x2 ? -1 : 1;
			int D = 2 * dx - dy;

			for (int y = y1; y <= y2; y++)
			{
				DrawPixel(x, y, color);
				if (D > 0)
				{
					x += xi;
					D -= 2 * dy;
				}

				D += 2 * dx;
			}
		}
	}
}

template <typename T>
class Vector2
{
public:
	Vector2() {}
	Vector2(T x, T y)
	{
		this->x = x;
		this->y = y;
	}

	Vector2& operator=(const Vector2& v)
	{
		x = v.x;
		y = v.y;
		return *this;
	}

	Vector2 operator+(const Vector2& v)
	{
		return Vector2(x + v.x, y + v.y);
	}

	Vector2 operator-(const Vector2& v)
	{
		return Vector2(x - v.x, y - v.y);
	}

	Vector2& operator+=(const Vector2& v)
	{
		x += v.x;
		y += v.y;
		return *this;
	}

	Vector2& operator-=(const Vector2& v)
	{
		x -= v.x;
		y -= v.y;
		return *this;
	}

	T x = 0.0f;
	T y = 0.0f;
};
typedef Vector2<int> Vector2i;
typedef Vector2<float> Vector2f;

class RectangleDemo
{
public:
	void setSize(Vector2f v)
	{
		size = v;

		position[1].x = position[0].x + v.x;
		position[1].y = position[0].y;

		position[2] = position[0] + v;

		position[3].x = position[0].x;
		position[3].y = position[0].y + v.y;

		origin = position[0];

		float tempR = rotation;
		rotation = 0.0f;
		setRotation(tempR);
	}

	Vector2f getSize()
	{
		return size;
	}

	void setOrigin(Vector2f v)
	{
		origin = v;
	}

	Vector2f getOrigin()
	{
		return origin;
	}

	void setPosition(Vector2f v)
	{
		move(v - origin);
	}

	Vector2f getPosition(int i)
	{
		return position[i];
	}

	void setColor(Pixel p)
	{
		color = p;
	}

	Pixel getColor()
	{
		return color;
	}

	void setRotation(float r)
	{
		rotate(r - rotation);
	}

	float getRotation()
	{
		return rotation;
	}

	void rotate(float r)
	{
		rotation += r;
		if (rotation >= 360.0f) rotation -= 360.0f;
		if (rotation <= -360.0f) rotation += 360.0f;

		r *= 3.14159265f / 180.0f;

		for (int i = 0; i < 4; i++)
		{
			position[i] -= origin;

			float tempX = position[i].x;
			position[i].x = tempX * cos(r) - position[i].y * sin(r);
			position[i].y = tempX * sin(r) + position[i].y * cos(r);

			position[i] += origin;
		}
	}

	void move(Vector2f v)
	{
		for (int i = 0; i < 4; i++)
		{
			position[i] += v;
		}

		origin += v;
	}

	void draw()
	{
		if (rotation == 0.0f || rotation == 90.0f)
		{
			for (int i = position[0].y; i <= position[2].y; i++)
			{
				DrawLine(position[0].x, i, position[1].x, i, color);
			}
		}

		DrawLine(position[0].x, position[0].y, position[1].x, position[1].y, color);
		DrawLine(position[1].x, position[1].y, position[2].x, position[2].y, color);
		DrawLine(position[2].x, position[2].y, position[3].x, position[3].y, color);
		DrawLine(position[3].x, position[3].y, position[0].x, position[0].y, color);
	}

private:
	Vector2f size;
	Vector2f position[4];
	Vector2f origin;

	float rotation = 0.0f;

	Pixel color = Pixel(255, 255, 255);
};

class TriangleDemo
{
public:
	void setSize(Vector2f v1, Vector2f v2, Vector2f v3)
	{
		position[0] = v1;
		position[1] = v2;
		position[2] = v3;

		origin = position[0];

		float tempR = rotation;
		rotation = 0.0f;
		setRotation(tempR);
	}

	void setOrigin(Vector2f v)
	{
		origin = v;
	}

	Vector2f getOrigin()
	{
		return origin;
	}

	void setPosition(Vector2f v)
	{
		move(v - origin);
	}

	Vector2f getPosition(int i)
	{
		return position[i];
	}

	void setColor(Pixel p)
	{
		color = p;
	}

	Pixel getColor()
	{
		return color;
	}

	void setRotation(float r)
	{
		rotate(r - rotation);
	}

	float getRotation()
	{
		return rotation;
	}

	void rotate(float r)
	{
		if (rotation >= 360.0f) rotation -= 360.0f;
		if (rotation <= -360.0f) rotation += 360.0f;

		rotation += r;
		r *= 3.14159265 / 180;

		for (int i = 0; i < 3; i++)
		{
			position[i] -= origin;

			float tempX = position[i].x;
			position[i].x = tempX * cos(r) - position[i].y * sin(r);
			position[i].y = tempX * sin(r) + position[i].y * cos(r);

			position[i] += origin;
		}
	}

	void move(Vector2f v)
	{
		for (int i = 0; i < 3; i++)
		{
			position[i] += v;
		}

		origin += v;
	}

	void draw()
	{
		Vector2f v1 = position[0];
		Vector2f v2 = position[1];
		Vector2f v3 = position[2];

		if (v1.y > v2.y)
		{
			std::swap(v1.x, v2.x);
			std::swap(v1.y, v2.y);
		}
		if (v2.y > v3.y)
		{
			std::swap(v2.x, v3.x);
			std::swap(v2.y, v3.y);
		}
		if (v1.y > v2.y)
		{
			std::swap(v1.x, v2.x);
			std::swap(v1.y, v2.y);
		}

		if (v2.y == v3.y)
		{
			fillBottomFlatTriangle(v1, v2, v3, color);
		}
		else if (v1.y == v2.y)
		{
			fillTopFlatTriangle(v1, v2, v3, color);
		}
		else
		{
			Vector2f v4 = Vector2f((int)(v1.x + ((float)(v2.y - v1.y) / (float)(v3.y - v1.y)) * (v3.x - v1.x)), v2.y);

			fillBottomFlatTriangle(v1, v2, v4, color);
			fillTopFlatTriangle(v2, v4, v3, color);
		}
	}

private:
	void fillBottomFlatTriangle(Vector2f v1, Vector2f v2, Vector2f v3, Pixel color)
	{
		float invslope1 = (v2.x - v1.x) / (v2.y - v1.y);
		float invslope2 = (v3.x - v1.x) / (v3.y - v1.y);

		float curx1 = v1.x;
		float curx2 = v1.x;

		for (int scanlineY = v1.y; scanlineY <= v2.y; scanlineY++)
		{
			DrawLine((int)curx1, scanlineY, (int)curx2, scanlineY, color);
			curx1 += invslope1;
			curx2 += invslope2;
		}
	}

	void fillTopFlatTriangle(Vector2f v1, Vector2f v2, Vector2f v3, Pixel color)
	{
		float invslope1 = (v3.x - v1.x) / (v3.y - v1.y);
		float invslope2 = (v3.x - v2.x) / (v3.y - v2.y);

		float curx1 = v3.x;
		float curx2 = v3.x;

		for (int scanlineY = v3.y; scanlineY > v1.y; scanlineY--)
		{
			DrawLine((int)curx1, scanlineY, (int)curx2, scanlineY, color);
			curx1 -= invslope1;
			curx2 -= invslope2;
		}
	}

private:
	Vector2f position[3];
	Vector2f origin;

	float rotation = 0.0f;

	Pixel color = Pixel(255, 255, 255);
};

class CircleDemo
{
public:
	void setSize(float r)
	{
		radius = r;
	}

	float getRadius()
	{
		return radius;
	}

	void setOrigin(Vector2f v)
	{
		origin = v;
	}

	Vector2f getOrigin()
	{
		return origin;
	}

	void setPosition(Vector2f v)
	{
		move(v - origin);
	}

	Vector2f getPosition()
	{
		return position;
	}

	void setColor(Pixel p)
	{
		color = p;
	}

	Pixel getColor()
	{
		return color;
	}

	void move(Vector2f v)
	{
		position += v;
		origin += v;
	}

	void draw()
	{
		int x = 0;
		int y = radius;
		int d = 3 - 2 * radius;

		drawCircle(position.x, position.y, x, y);

		while (y >= x)
		{
			x++;

			if (d > 0)
			{
				y--;
				d = d + 4 * (x - y) + 10;
			}
			else
			{
				d = d + 4 * x + 6;
			}

			drawCircle(position.x, position.y, x, y);
		}
	}

private:
	void drawCircle(int xc, int yc, int x, int y)
	{
		DrawLine(xc + x, yc + y, xc - x, yc + y, color);
		DrawLine(xc + x, yc - y, xc - x, yc - y, color);
		DrawLine(xc + y, yc + x, xc - y, yc + x, color);
		DrawLine(xc + y, yc - x, xc - y, yc - x, color);
	}

private:
	float radius = 10.0f;
	Vector2f position;
	Vector2f origin;

	Pixel color = Pixel(255, 255, 255);
};

void CreateOpenGL()
{
	DeviceContext = GetDC(hWnd);

	PIXELFORMATDESCRIPTOR pfd =
	{
		sizeof(PIXELFORMATDESCRIPTOR), 1,
		PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
		PFD_TYPE_RGBA, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		PFD_MAIN_PLANE, 0, 0, 0, 0
	};

	int pf = ChoosePixelFormat(DeviceContext, &pfd);
	SetPixelFormat(DeviceContext, pf, &pfd);

	RenderContext = wglCreateContext(DeviceContext);
	wglMakeCurrent(DeviceContext, RenderContext);
}

void CreateTexture()
{
	glEnable(GL_TEXTURE_2D);
	glGenTextures(1, &Texture);
	glBindTexture(GL_TEXTURE_2D, Texture);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, ScreenWidth, ScreenHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixel);
}

//int MazeWidth = 20;
//int MazeHeight = 10;

void EngineThread()
{
	CreateOpenGL();
	CreateTexture();

	// ========== CREATE RESOURCES =========================================================
	int  MazeWidth = 40;
	int  MazeHeight = 25;
	int  PathWidth = 3;
	Pixel color(0, 255, 0);

	int* maze = new int[MazeWidth * MazeHeight];
	memset(maze, 0x00, MazeWidth * MazeHeight * sizeof(int));

	srand(time(NULL));
	int x = rand() % MazeWidth;
	int y = rand() % MazeHeight;
	std::stack<std::pair<int, int>> stack;
	stack.push(std::make_pair(x, y));

	enum
	{
		CELL_PATH_N = 0x01,
		CELL_PATH_E = 0x02,
		CELL_PATH_S = 0x04,
		CELL_PATH_W = 0x08,
		CELL_VISITED = 0x10,
	};

	maze[y * MazeWidth + x] = CELL_VISITED;
	int m_nVisitedCells = 1;
	// =====================================================================================

	auto begin = std::chrono::system_clock::now();
	auto end = std::chrono::system_clock::now();

	while (EngineStatus)
	{
		// Time
		end = std::chrono::system_clock::now();
		std::chrono::duration<float> ET = end - begin;
		begin = std::chrono::system_clock::now();
		ElapsedTime = ET.count();

		// Keyboard Input
		for (int i = 0; i < 256; i++)
		{
			KeyState[i].press = 0;
			KeyState[i].release = 0;

			if (KeyNewState[i] != KeyOldState[i])
			{
				if (KeyNewState[i])
				{
					KeyState[i].press = 1;
					KeyState[i].hold = 1;
				}
				else
				{
					KeyState[i].release = 1;
					KeyState[i].hold = 0;
				}
			}

			KeyOldState[i] = KeyNewState[i];
		}

		// Mouse Input
		for (int i = 0; i < 3; i++)
		{
			MouseState[i].press = 0;
			MouseState[i].release = 0;

			if (MouseNewState[i] != MouseOldState[i])
			{
				if (MouseNewState[i])
				{
					MouseState[i].press = 1;
					MouseState[i].hold = 1;
				}
				else
				{
					MouseState[i].release = 1;
					MouseState[i].hold = 0;
				}
			}

			MouseOldState[i] = MouseNewState[i];
		}

		// Mouse Position
		MousePositionX = MPX;
		MousePositionY = MPY;

		// ========== UPDATE =============================================================== 
		Sleep(10);
		
		auto offset = [&](int x, int y)
		{
			return (stack.top().second + y) * MazeWidth + (stack.top().first + x);
		};

		// Algorytm
		if (m_nVisitedCells < MazeWidth * MazeHeight)
		{
			std::vector<int> neighbours;

			// Up
			if (stack.top().second > 0 && (maze[offset(0, -1)] & CELL_VISITED) == 0)
				neighbours.push_back(0);
			// Right
			if (stack.top().first < MazeWidth - 1 && (maze[offset(1, 0)] & CELL_VISITED) == 0)
				neighbours.push_back(1);
			// Down
			if (stack.top().second < MazeHeight - 1 && (maze[offset(0, 1)] & CELL_VISITED) == 0)
				neighbours.push_back(2);
			// Left
			if (stack.top().first > 0 && (maze[offset(-1, 0)] & CELL_VISITED) == 0)
				neighbours.push_back(3);

			// 
			if (!neighbours.empty())
			{
				// Choose one available at random
				int next_cell_dir = neighbours[rand() % neighbours.size()];

				// Create a path
				switch (next_cell_dir)
				{
				case 0: // Up
					maze[offset(0, -1)] |= CELL_VISITED | CELL_PATH_S;
					maze[offset(0, 0)] |= CELL_PATH_N;
					stack.push(std::make_pair((stack.top().first + 0), (stack.top().second - 1)));
					break;

				case 1: // East
					maze[offset(+1, 0)] |= CELL_VISITED | CELL_PATH_W;
					maze[offset(0, 0)] |= CELL_PATH_E;
					stack.push(std::make_pair((stack.top().first + 1), (stack.top().second + 0)));
					break;

				case 2: // Right
					maze[offset(0, +1)] |= CELL_VISITED | CELL_PATH_N;
					maze[offset(0, 0)] |= CELL_PATH_S;
					stack.push(std::make_pair((stack.top().first + 0), (stack.top().second + 1)));
					break;

				case 3: // Left
					maze[offset(-1, 0)] |= CELL_VISITED | CELL_PATH_E;
					maze[offset(0, 0)] |= CELL_PATH_W;
					stack.push(std::make_pair((stack.top().first - 1), (stack.top().second + 0)));
					break;

				}

				m_nVisitedCells++;
			}
			else
			{
				stack.pop();
			}
		}

		// Draw Maze
		for (int x = 0; x < MazeWidth; x++)
		{
			for (int y = 0; y < MazeHeight; y++)
			{
				for (int py = 0; py < PathWidth; py++)
					for (int px = 0; px < PathWidth; px++)
					{
						if (maze[y * MazeWidth + x] & CELL_VISITED)
							DrawPixel(x * (PathWidth + 1) + px, y * (PathWidth + 1) + py, color);
						else
							DrawPixel(x * (PathWidth + 1) + px, y * (PathWidth + 1) + py, color);
					}

				// Draw passageways 
				for (int p = 0; p < PathWidth; p++)
				{
					if (maze[y * MazeWidth + x] & CELL_PATH_S)
						DrawPixel(x * (PathWidth + 1) + p, y * (PathWidth + 1) + PathWidth, color);

					if (maze[y * MazeWidth + x] & CELL_PATH_E)
						DrawPixel(x * (PathWidth + 1) + PathWidth, y * (PathWidth + 1) + p, color);
				}
			}
		}
		// =================================================================================

		// Render Texture
		glViewport(ViewportX, ViewportY, ViewportWidth, ViewportHeight);
		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, ScreenWidth, ScreenHeight, 
			GL_RGBA, GL_UNSIGNED_BYTE, pixel);

		glBegin(GL_QUADS);
		glTexCoord2f(0.0, 1.0); glVertex2f(-1.0f, -1.0f);
		glTexCoord2f(0.0, 0.0); glVertex2f(-1.0f, 1.0f);
		glTexCoord2f(1.0, 0.0); glVertex2f(1.0f, 1.0f);
		glTexCoord2f(1.0, 1.0); glVertex2f(1.0f, -1.0f);
		glEnd();

		SwapBuffers(DeviceContext);

		// Show AplicationName + FPS
		FrameCount++;
		FrameTime += ElapsedTime;

		if (FrameTime >= 1)
		{
			std::string temp = ApplicationName + " - FPS: " + std::to_string(FrameCount);
			std::wstring title = std::wstring(temp.begin(), temp.end());
			SetWindowText(hWnd, title.c_str());

			FrameCount = 0;
			FrameTime--;
		}
	}

	// ========== RELEASE RESOURCES ========================================================

	// =====================================================================================

	// Cleanup
	delete[] pixel;
	wglMakeCurrent(NULL, NULL);
	wglDeleteContext(RenderContext);
	PostMessage(hWnd, WM_DESTROY, 0, 0);
}

void StartEngine()
{
	EngineStatus = 1;
	CreateMainWindow();
	std::thread engine_thread = std::thread(EngineThread);

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	engine_thread.join();
}

int main()
{
	ApplicationName = "Labirynt";
	SetWindowSize(160, 100, 8, 8);
	StartEngine();
}


